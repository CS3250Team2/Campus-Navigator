'use strict';
process.env.BABEL_ENV = 'development';
process.env.NODE_ENV = 'development';
process.on('unhandledRejection', err => {
  throw err;
});

const fs = require('fs');
const chalk = require('chalk');
const webpack = require('webpack');
const WebpackDevServer = require('webpack-dev-server');
const clearConsole = require('react-dev-utils/clearConsole');
const checkRequiredFiles = require('react-dev-utils/checkRequiredFiles');
const {
  choosePort,
  createCompiler,
  prepareProxy,
  prepareUrls,
} = require('react-dev-utils/WebpackDevServerUtils');
const openBrowser = require('react-dev-utils/openBrowser');
//const paths = require('../config/paths');// this is still being blocked by package.json
//i see a theme of pathing not working
//const config = require('../config/webpack.config.dev'); //haha im figuring you out.
//const createDevServerConfig = require('../config/webpackDevServer.config');// yep its anything with pathing
//const useYarn = fs.existsSync(paths.yarnLockFile);//turns out ryan figured out the problem and fixed it. It was to do with the package-lock.json it had an extra HEAD>>> in there
const isInteractive = process.stdout.isTTY;

// Warn and crash if required files are missing
// if (!checkRequiredFiles([paths.appHtml, paths.appIndexJs])) {
//   process.exit(1);
// }
const DEFAULT_PORT = parseInt(process.env.PORT, 10) || 3000;
const HOST = process.env.HOST || '0.0.0.0';
if (process.env.HOST) {
  console.log(
    chalk.cyan(
      `Attempting to bind to HOST environment variable: ${chalk.yellow(
        chalk.bold(process.env.HOST)
      )}`
    )
  );
  console.log(
    `If this was unintentional, check that you haven't mistakenly set it in your shell.`
  );
  console.log(`Learn more here: ${chalk.yellow('http://bit.ly/2mwWSwH')}`);
  console.log();
}
// We attempt to use the default port but if it is busy, we offer the user to
// run on a different port. `choosePort()` Promise resolves to the next free port.
choosePort(HOST, DEFAULT_PORT)
  .then(port => {
    if (port == null) {
      // We have not found a port.
      return;
    }
    const protocol = process.env.HTTPS === 'true' ? 'https' : 'http';
    const appName = require(paths.appPackageJson).name;
    const urls = prepareUrls(protocol, HOST, port);
    // Create a webpack compiler that is configured with custom messages.
    const compiler = createCompiler(webpack, config, appName, urls, useYarn);
    // Load proxy config
    const proxySetting = require(paths.appPackageJson).proxy;
    const proxyConfig = prepareProxy(proxySetting, paths.appPublic);
    // Serve webpack assets generated by the compiler over a web sever.
    const serverConfig = createDevServerConfig(
      proxyConfig,
      urls.lanUrlForConfig
    );
    const devServer = new WebpackDevServer(compiler, serverConfig);
    // Launch WebpackDevServer.
    devServer.listen(port, HOST, err => {
      if (err) {
        return console.log(err);
      }
      if (isInteractive) {
        clearConsole();
      }
      console.log(chalk.cyan('Starting the development server...\n'));
      openBrowser(urls.localUrlForBrowser);
    });

    ['SIGINT', 'SIGTERM'].forEach(function(sig) {
      process.on(sig, function() {
        devServer.close();
        process.exit();
      });
    });
  })
  .catch(err => {
    if (err && err.message) {
      console.log(err.message);
    }
    process.exit(1);
  });

const port = process.env.PORT || 3000;
   const express = require('express');
   const bodyParser = require('body-parser');
   const multer = require('multer');
   const uuidv4 = require('uuid/v4');
   const path = require('path');
   const spawn = require("child_process").spawn;
   // code found on https://blog.stvmlbrn.com/2017/12/17/upload-files-using-react-to-node-express-server.html
   // configure storage
   const storage = multer.diskStorage({
     destination: (req, file, cb) => {
       /*
         Files will be saved in the 'uploads' directory. Make
         sure this directory already exists!
       */
       cb(null, './uploads');
     },
     filename: (req, file, cb) => {
       /*
         uuidv4() will generate a random ID that we'll use for the
         new filename. We use path.extname() to get
         the extension from the original file name and add that to the new
         generated ID. These combined will create the file name used
         to save the file on the server and will be available as
         req.file.pathname in the router handler.
       */
       const newFilename = `${uuidv4()}${path.extname(file.originalname)}`;
       cb(null, newFilename);
     },
   });
   // create the multer instance that will be used to upload/save the file
   const upload = multer({ storage });

   const app = express();

   app.use(bodyParser.json());
   app.use(bodyParser.urlencoded({ extended: true }));

   app.post('/', upload.single('selectedFile'), (req, res) => {
     /*
       We now have a new req.file object here. At this point the file has been saved
       and the req.file.filename value will be the name returned by the
       filename() function defined in the diskStorage configuration. Other form fields
       are available here in req.body.
     */
     res.send();
   });

   app.listen(port, () => console.log(`Server listening on port ${port}`));
